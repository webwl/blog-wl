学习思路


- 为什么那么快？
- 怎么使用原生ESM文件？
- 什么叫冷启动？
- ESbuild做了什么？
- 第二就是打包交给rollup，vite在其中做了什么。
- 非ESM模块化，怎么处理

# 为什么要用vite？
`vite`对于开发环境特别友好，它可以启动的特别快。

> 当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。  ———— 官方文档

从官网的介绍中我们可以看到，`vite`主要解决的，是在开发环境中的使用体验。解决如`webpack`在启动项目时漫长的等待。

（是否意味着并没有其他更加有力的理由去取代生产环境的webpack?毕竟生产环境谁会在乎启动速度？）

# 为什么那么快？
## 从npm run dev开始，到正式运行，经历了什么？

```
...
webpack building (12%)

...

√ Webpack
  Compiled successfully in 3.21s
```
`webpack`在启动项目时会经历漫长的编译过程，从入口开始逐步进行语法分析，依赖收集，代码转译，打包合并，代码优化，最终编译成低版本高兼容性的代码。而`vite`是则拒绝将精力放在代码的兼容性上，`vite`默认你是用的是现代浏览器，现代浏览器就应该原生支持ESM规范！（赞同）。

但`vite`并非什么都没有做
```
import { someMethod } from 'my-dep'
```
`vite`将会检测到所有被加载的源文件中的此类裸模块导入，并执行预构建,重写导入为合法`URL`。

### 总结
`webpack`编译整个项目，`vite`预构建依赖

## 预构建
### `vite`的依赖预构建做了什么？有什么目的？
- CommonJS 和 UMD 兼容性: 

开发阶段中，`Vite` 的开发服务器将所有代码视为原生 `ES` 模块。因此，`Vite` 必须先将作为 `CommonJS` 或 `UMD` 发布的依赖项转换为 `ESM`。
当转换 `CommonJS` 依赖时，`Vite` 会执行智能导入分析，这样即使导出是动态分配的（如 `React`）

- 性能

Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。一些包将它们的 ES 模块构建作为许多单独的文件相互导入。例如，lodash-es 有超过 600 个内置模块！当我们执行 import { debounce } from 'lodash-es' 时，浏览器同时发出 600 多个 HTTP 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。
通过预构建 lodash-es 成为一个模块，我们就只需要一个 HTTP 请求了！

### esbuild
预构建通过 esbuild 执行，所以它通常非常快。

至于esbuild为什么非常快···
- 它是用 Go 语言编写的，该语言可以编译为原生代码；
- 解析，打印和源映射生成全部完全并行化；
- 无需昂贵的数据转换，只需很少的几步即可完成所有操作；
- 编写代码时处处注意速度表现，并尽量避免不必要的配置。

### 








# 参考资料
- [vite官方文档](https://cn.vitejs.dev/guide/)
- [掘金-vite预构建](https://juejin.cn/post/6930407545374785543)